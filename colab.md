author: shogo.yamada
summary: 「単体テストの考え方/使い方」という本から作成したcolab
id: original_unit_test_colab
categories: codelab,markdown
environments: Web
status: Draft
feedback link: https://github.com/yshogo
analytics account: XXXXXXXX

# Codelab: Jetpack Composeでの単体テスト学習

## はじめに

このCodelabでは、「単体テストの考え方/使い方」という本の内容に基づき、Androidアプリの開発における単体テストの基礎を学びます。本Codelabでは特に、Jetpack Composeを用いたサンプルコードを使用して、実際にどのようにテストを実装するかを解説していきます。


<aside class="negative">
注意：
このCodelabは著者山田の解釈を元に作成されていますが、必ずしも本の内容を網羅しているわけではありません。
また、解釈に誤りが含まれている可能性もあります。そのため、このCodelabを通じて基本的な理解を深めるだけでなく、必ず原書も併せてお読みいただき、より深い理解を得ていただくことを推奨します。
</aside>

### 目的

このCodelabの目的は、Jetpack Composeを活用したテストの実装方法を学ぶことです。基本的なテストの考え方を学ぶだけでなく、実際の開発にすぐに応用できるテクニックも紹介します。

### 対象読者

- Android開発に携わっている方
- 単体テストの基本的な概念を学びたい方

### 前提条件

- Android開発環境が整っていること
- Kotlinの基本的な知識があること
- Jetpack Composeの基本的な使い方を理解していること

### 必要なもの
- Android 開発に関する基本的な知識
- Android Studio（まだお持ちでない場合は[こちら](https://developer.android.com/studio/?hl=ja)からダウンロードしてください）
- Android Emulator または Android デバイス（Android Studio から入手可能）
- サンプルコード（次の手順を参照）

## Step 1: プロジェクトセットアップ
概要: シンプルなカウンターアプリを作成します。ボタンを押すたびにカウントが増加し、テキスト表示が更新されます。

![creating_app](./images/step1_countup.png)

### GitHub からクローンを作成する
GitHub からこの Codelab のクローンを作成するには、次のコマンドを実行します。

```
git clone https://github.com/yshogo/unit-test-codelab-sample.git
cd unittestcodelabsample
git checkout master
```

#### 概要
シンプルなカウンターアプリを作成します。このアプリでは、ボタンを押すたびにカウントが増加し、テキスト表示が更新されるようになっています。 

#### 主なクラス

- **CounterViewModel**: カウントロジックを管理するViewModel
- **CounterScreen**: Jetpack Composeでカウント表示とボタンを実装

#### 次のステップ
次のステップでは、このカウンターアプリの increment() メソッドに対する単体テストを実装し、その動作を検証していきます。

## Step 2: 単体テストの目的
ソフトウェア開発において、単体テストの第一の目的はコード設計を改善することではなく、プロジェクトを**持続可能**なものにすることです。この「持続可能性」が重要な理由は、ソフトウェアは新しい機能や変更が加わるごとに自然と複雑さが増していき、保守性が低下しやすくなるためです。この複雑化（エントロピー）の進行を防ぐために、単体テストはコードの変更が意図しない影響を与えていないかを確認する「セーフティネット」としての役割を果たします。

### ソフトウェアエントロピーと単体テストの役割
**ソフトウェアエントロピー**は、機能追加や改良を行うたびにコードが複雑化し、保守が難しくなる現象を指します。単体テストはこのエントロピーを防ぎ、コードが安定した状態を保つことに貢献します。単体テストの準備には初期の労力が必要ですが、その労力は後々のデバッグや修正の回数を減らすことで、開発効率と保守性を向上させます。

![entropy](./images/entropy.jpg)

<aside class="positive">
例え話

単体テストは、部屋の大掃除に似ています。最初に時間をかけて徹底的に整理整頓するのは大変ですが、きちんと片付けをしておけば、後々は少しの手間で綺麗な状態を維持できるようになります。同様に、プロジェクトに最初から十分な単体テストを導入することで、最初は時間と労力が必要でも、長期的にはコードの保守が格段に楽になります。例えば、プロダクションコードのリファクタリング時にテストコードも見直し、テストが失敗した際はその原因をすぐに修正するなどの作業を通じて、テストの価値が維持され、コード全体の品質も安定します。しかし、適切なテスト設計やメンテナンスを怠ると、まるで片付けが進まない部屋のように、コードも複雑さとエラーが蓄積し、最終的にはプロジェクト全体が重荷になってしまうのです。
</aside>

### 単体テストの価値と保守コストのバランス

単体テストは、コードの品質を保ちながら開発を進める上で重要ですが、テストの価値を発揮するためには単体テストの価値と保守コストの両方を考慮しなければなりません。
そしてこのコストは下記に挙げるさまざまな作業で費やされる時間が積み重なることで増加していきます。

- プロダクションコードのリファクタリングに伴ってテスト・コードをリファクタリングすること
- プロダクションコードを変更するたびにテストを実施すること
- テストが間違って失敗した際にその対処をすること
- プロダクションコードがどのように振る舞うのかを理解するためにテストコードを読むこと

これらの要点を押さえて、テストスイートを設計することで、持続可能でプロジェクト全体に貢献する価値あるテストを設計することができます。
作成した単体テストへの保守コストがあまりにもかかりすぎると、その単体テストの価値がなくなってしまう、もしくはマイナスになってしまうことがあります。

### コードカバレッジとテストの質
コードカバレッジ（テスト実行中に実行されるコード行の割合）は、テストスイートの品質を測る指標として使用されることが多いですが、**カバレッジだけではテストの質は保証できません**。カバレッジに過度にこだわると、カバレッジを上げるためだけに表面的なテストや冗長なテストを書く傾向が生まれることがあります。良質なテストは、カバレッジに頼るのではなく、ビジネスロジックのように失敗の影響が大きい部分に焦点を当てるべきです。

### 優れたテストスイートの特徴
優れたテストスイートには以下の特徴があります：

- **開発サイクルに統合されている**：テストは開発プロセスに組み込まれ、後付けではありません。
- **コードベースの特に重要な部分のみがテスト対象となっている**：特にビジネスロジックなどを含む部分（ドメイン・モデル）に重点を置いたテストが行われる。
  - インフラに関するコード
  - 外部サービスや依存関係にあるもの（例：データベースやサード・パーティのシステム）
- **最小限の保守コストで最大限の価値を発揮する**：テストがプロジェクト全体に持続可能な成長をもたらすよう工夫されている。

このように設計された単体テストによって、コードベースの複雑化を抑えながら、プロジェクト全体が安心して成長できる基盤を築くことができます。

### 次のステップ
次のステップでは、単体テストの書き方や考え方の違いを深掘りし、古典学派とロンドン学派という2つの主要なアプローチについて学びます。

## Step 3: 単体テストの学派（古典 vs ロンドン）
単体テストには、**古典学派**と**ロンドン学派**という2つの主要な考え方があります。この違いは、特に「テストをどこまで隔離するか」という点に基づいており、それぞれが異なるアプローチでテストの信頼性や独立性を確保しています。

### 単体テストの定義
一般に単体テストは以下のように定義されます：
- 少量のコードで検証ができる
- 実行時間が短い
- 他のコンポーネントから隔離されている

この「隔離」に対する考え方の違いが、古典学派とロンドン学派の違いを生んでいます。以下で、それぞれのアプローチを見ていきましょう。

### 古典学派
古典学派では、実際のインスタンスをテストケース内で生成し、プロダクションコードの実際の挙動をテストします。依存関係も基本的に実際のものを使用するため、コードそのものの動作を確認しやすいという特徴があります。以下に古典学派の例を示します：

```kotlin
@Test
fun `test person instance creation`() {
    // インスタンスを作成
    val person = Person("Taro", 25)
    
    // プロパティの値をテスト
    assertEquals("Taro", person.name, "名前が正しくありません")
    assertEquals(25, person.age, "年齢が正しくありません")
}
```

この方法では、依存関係が増えるとテストが複雑になることもありますが、コードの設計に依存が少なくなるような工夫を促す効果もあります。

### ロンドン学派
ロンドン学派は、テスト対象の依存関係をモック化して独立したテストを実行する「モック主義者」とも呼ばれるアプローチです。テスト内でモックを生成し、必要な動作のみを模倣させることで、テストケースごとにデータや状態が完全に独立したものになります。以下にロンドン学派の例を示します：

```kotlin
@Test
fun `test person instance creation`() {
    // モックを作成
    val person = mock<Person>()
    whenever(person.name).thenReturn("Taro")
    whenever(person.age).thenReturn(25)
    
    // プロパティの値をテスト
    assertEquals("Taro", person.name, "名前が正しくありません")
    assertEquals(25, person.age, "年齢が正しくありません")
}
```

ロンドン学派は、テスト対象のクラス（「1つのクラス」）を単体と見なし、他の依存を全てモック化することによって独立性を保ちます。このため、依存が多いコードに適していますが、モック化の量が増えるとテストのメンテナンスが複雑になる可能性があります。

### 学派の特徴と選択のポイント
- 古典学派：実際のプロダクションコードを使い、テストケースをコード全体の挙動と合わせて設計します。設計の見直しを促し、シンプルなテストが可能です。
- ロンドン学派：モックを多用し、テストをクラス単位で隔離して実施します。依存を多く持つ複雑なコードには適していますが、モックが多くなるとテストが煩雑になることがあります。

### ロンドン学派は課題もいくつか抱えている。
ロンドン学派の長所は魅力的なように思えるが、単体テストにおいて、テスト対象の焦点をクラスに当てることは間違いです。
焦点を当てるべきは１単位のコードではなく、１単位の振る舞いです。

|                  |      隔離対象                |          単体の意味                      |
|------------------|------------------------------------|----------------------------------------|
| ロンドン学派          | 単体 | 1つのクラス |
| 古典学派       | テスト・ケース         | １つのクラス、もしくは、同じ目的を達成するためのクラスの１グループ |


この場合、ロンドン学派では、検証内容が詳細になりすぎてしまうことがあります。単体テストが内部構造と深く結びついてしまうことで、保守性の低いテストコードになってしまうからです。（詳細についてはstep5で説明します。）

### 次のステップ
次のステップでは、単体テストの基本的な構造と、広く使用される**AAAパターン**（Arrange-Act-Assert）について学びます。

## Step 4: 単体テストの構造とAAAパターン

この章では、単体テストを書く際の基本構造である **AAAパターン** と適切なテスト命名規則について学びます。これにより、一貫性があり、わかりやすいテストコードを作成できるようになります。

### AAAパターン

単体テストでは、**AAAパターン (Arrange, Act, Assert)** を使用してテストを構成します。以下に各フェーズの詳細を説明します。

#### 1. 準備 (Arrange)

テスト対象システム (System Under Test, SUT) とその依存関係を設定し、テストの前提条件を満たす状態を作ります。

- **やるべきこと**
  - テスト対象オブジェクトのインスタンス化。
  - 必要な依存関係 (モックやスタブ) の準備。
  - テストデータの設定。

- **ベストプラクティス**
  - 複雑な設定は **privateメソッド** で共通化する。
  - **コンストラクタで複雑な処理を行わない**。
  - **privateなfactoryメソッド** を利用する。

---

#### 2. 実行 (Act)

テスト対象の振る舞いを実行します。

- **やるべきこと**
  - テスト対象メソッドを1回だけ呼び出す。
  - 実行結果 (戻り値や例外) を保持する。

- **ベストプラクティス**
  - 実行フェーズは **1行** で完結するように設計する。
  - 実行フェーズが複数行になる場合は設計の見直しを検討する。

---

#### 3. 確認 (Assert)

実行結果が期待通りであることを検証します。

- **やるべきこと**
  - 戻り値や状態を確認する。
  - モックが想定通りに呼び出されたか検証する。

- **ベストプラクティス**
  - **if文を使用しない**。条件分岐が必要な場合はテストケースを分割する。
  - コメントを記述せず、コードの可読性で意図を伝える。


### サンプルコード

以下は、AAAパターンを適用した単純なテストケースの例です。

```kotlin
fun testAddition() {
    // Arrange
    val calculator = Calculator()
    val a = 5
    val b = 3

    // Act
    val result = calculator.add(a, b)

    // Assert
    assertEquals(8, result)
}
```

### テストメソッドの命名規則
単体テストのメソッド名は、非開発者にもわかりやすい名前を付けることが重要です。

#### 命名のポイント
1. 英語の文法に従う:
   - 明確で簡潔な文にする。
   - テストの目的や期待される振る舞いを表現する。

2. アンダースコア (_) を使用:
   - 単語を区切り、可読性を向上させる。
3. 振る舞いを重視する:
   - テスト対象のメソッド名は含めず、振る舞いを説明する。
   - should be のような曖昧な表現を避け、is を使う。
---

#### 適切な例
- Delivery_with_a_past_date_is_invalid()
- User_with_insufficient_balance_cannot_make_a_purchase()

### 避けるべきアンチパターン
1. if文の使用
- テストコードに条件分岐を含めるのは避ける。
- 必要に応じてテストケースを分割する。

2. should be の使用
- 振る舞いを直接記述するべきで、曖昧な表現を避ける。

3. 複雑な実行フェーズ
- 実行フェーズが複数行になる場合は設計を見直す。

### まとめ
この章では、AAAパターンを使用して一貫性のある単体テストを書く方法を学びました。また、適切なテスト命名規則を守ることで、誰にでもわかりやすいテストを作成できるようになります。これらの知識を活用して、品質の高いテストコードを書いていきましょう。

## Step 5: 良いテストの4本の柱
良い単体テストを構成する4つの柱について説明します。これらの柱を理解し、バランスよく追求することで、テストコードの品質を向上させ、プロジェクト全体の持続可能な成長を実現できます。

---

## 良いテストの4本の柱

1. **退行 (Regression) に対する保護**
2. **リファクタリングへの耐性**
3. **迅速なフィードバック**
4. **保守のしやすさ**

---

### 1. 退行 (Regression) に対する保護

退行とは、既存の機能にバグを持ち込むことです。良いテストは退行を早期に検知し、修正を可能にします。

- **目的**
  - 新たな変更が既存の動作を壊さないことを保証する。
  - 既存の機能が期待通りに動作し続けることを確認する。

- **注意点**
  - テストが変更の影響を正確に検知することが重要です。

---

### 2. リファクタリングへの耐性

リファクタリングによってテストが壊れる場合、特にコードが正しい挙動をしているのにテストが失敗することを**偽陽性**と呼びます。これを防ぐことがリファクタリング耐性の鍵です。

- **偽陽性の原因**
  - テストコードがプロダクションコードの内部実装に依存している場合、リファクタリングでテストが壊れやすくなります。

- **解決策**
  - **テスト対象のコードの内部実装からテストコードを切り離す**。
  - テストの検証対象を「観察可能な振る舞い」に限定する。
  - テスト対象のコードを呼び出す側の視点で結果を確認し、実装の詳細には依存しない。

**例**
```kotlin
fun testHtmlGeneration() {
    // Arrange
    val generator = HtmlGenerator()
    val data = SampleData()

    // Act
    val html = generator.generateHtml(data)

    // Assert
    assertTrue(html.contains("ExpectedMessage"))
}
```

### 3. 迅速なフィードバック
テストは、変更の影響をすばやくフィードバックする仕組みであるべきです。

- 利点
  - 問題が早期に発見されることで、修正が容易になる。
  - 開発者が安心してコードを変更できる。
- 注意点
  - フィードバックが遅いと、テストの価値が低下する。
  - テストの実行速度が開発の妨げにならないようにする。

### 4.保守のしやすさ
テストコードは簡潔で読みやすく、保守が容易であるべきです。

- ポイント

  - テストケースを理解するのに時間がかからないこと。
  - テストコードの量が少ないほど保守性が向上する。
  - プロダクションコードと同じレベルで可読性を重視する。
- 注意点

  - コードの量を圧縮するだけではなく、意図が明確に伝わる書き方を心がける。
  - 外部依存が多い場合、セットアップが煩雑になり保守が困難になるため、外部依存を最小限にする。

### 理想的なテストのバランス
4本の柱をすべて最大限満たすことは困難です。以下のようにトレードオフが発生する可能性があります。

1. 退行に対する保護、リファクタリングへの耐性、迅速なフィードバック は相互に競合する場合があります。
2. 保守のしやすさ は比較的追求しやすいが、テストコードの量や可読性に注意が必要です。

### ブラックボックステストとホワイトボックステスト
- ブラックボックステスト

  - 振る舞いに基づいてテストを行い、内部実装に依存しない。
  - テストの安定性を高めるために基本とするべきアプローチ。
- ホワイトボックステスト

  - 内部実装を分析し、未検証の経路を見つけ出して新しいテストケースを追加するために用いる。
  - 補完的な手法として活用する。

### まとめ
良い単体テストは、以下の4本の柱をバランスよく満たすことを目指します。

1. 退行に対する保護
2. リファクタリングへの耐性
3. 迅速なフィードバック
4. 保守のしやすさ

ただし、これらをすべて同時に最大限追求するのは困難なため、プロジェクトの性質や優先度に応じて最適なバランスを見つけることが重要です。テストはブラックボックステストを基本としつつ、必要に応じてホワイトボックステストを補完的に用いることで、安定したコードベースを実現しましょう。


## Step 6: テストダブルの活用
内容: モックとスタブの違いを理解し、ログを持つViewModelのテストでモック化を体験します。

## Step 7: 単体テストの3つの手法
内容: 出力値ベース、状態ベース、コミュニケーションベースの3つのテスト手法を示します。

## Step 8: 複雑なコードのリファクタリング
内容: ViewModelに履歴機能を持たせ、ビジネスロジックとUIの分離を学びます。

## Step 9: 完成形とまとめ
完成形コード: 最終的なCounterアプリとテストコードを確認します。
まとめ: テストの基本原則とJetpack Compose特有のUIテストの利点を確認し、リファクタリング耐性と保守性について学びます。
