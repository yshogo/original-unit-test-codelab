
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Codelab: Jetpack Composeでの単体テスト学習</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid="XXXXXXXX"
                  codelab-ga4id=""
                  id="original_unit_test_colab"
                  title="Codelab: Jetpack Composeでの単体テスト学習"
                  environment="web"
                  feedback-link="https://github.com/yshogo">
    
      <google-codelab-step label="はじめに" duration="0">
        <p>このCodelabでは、「単体テストの考え方/使い方」という本の内容に基づき、Androidアプリの開発における単体テストの基礎を学びます。本Codelabでは特に、Jetpack Composeを用いたサンプルコードを使用して、実際にどのようにテストを実装するかを解説していきます。</p>
<aside class="warning"><p> 注意： このCodelabは著者山田の解釈を元に作成されていますが、必ずしも本の内容を網羅しているわけではありません。 また、解釈に誤りが含まれている可能性もあります。そのため、このCodelabを通じて基本的な理解を深めるだけでなく、必ず原書も併せてお読みいただき、より深い理解を得ていただくことを推奨します。 </p>
</aside>
<h2 is-upgraded>目的</h2>
<p>このCodelabの目的は、Jetpack Composeを活用したテストの実装方法を学ぶことです。基本的なテストの考え方を学ぶだけでなく、実際の開発にすぐに応用できるテクニックも紹介します。</p>
<h2 is-upgraded>対象読者</h2>
<ul>
<li>Android開発に携わっている方</li>
<li>単体テストの基本的な概念を学びたい方</li>
</ul>
<h2 is-upgraded>前提条件</h2>
<ul>
<li>Android開発環境が整っていること</li>
<li>Kotlinの基本的な知識があること</li>
<li>Jetpack Composeの基本的な使い方を理解していること</li>
</ul>
<h2 is-upgraded>必要なもの</h2>
<ul>
<li>Android 開発に関する基本的な知識</li>
<li>Android Studio（まだお持ちでない場合は<a href="https://developer.android.com/studio/?hl=ja" target="_blank">こちら</a>からダウンロードしてください）</li>
<li>Android Emulator または Android デバイス（Android Studio から入手可能）</li>
<li>サンプルコード（次の手順を参照）</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Step 1: プロジェクトセットアップ" duration="0">
        <p>概要: シンプルなカウンターアプリを作成します。ボタンを押すたびにカウントが増加し、テキスト表示が更新されます。</p>
<p class="image-container"><img alt="creating_app" src="img/c58bb89799e99447.png"></p>
<h2 is-upgraded>GitHub からクローンを作成する</h2>
<p>GitHub からこの Codelab のクローンを作成するには、次のコマンドを実行します。</p>
<pre><code>git clone https://github.com/yshogo/unit-test-codelab-sample.git
cd unittestcodelabsample
git checkout master
</code></pre>
<h3 is-upgraded>概要</h3>
<p>シンプルなカウンターアプリを作成します。このアプリでは、ボタンを押すたびにカウントが増加し、テキスト表示が更新されるようになっています。</p>
<h3 is-upgraded>主なクラス</h3>
<ul>
<li><strong>CounterViewModel</strong>: カウントロジックを管理するViewModel</li>
<li><strong>CounterScreen</strong>: Jetpack Composeでカウント表示とボタンを実装</li>
</ul>
<h3 is-upgraded>次のステップ</h3>
<p>次のステップでは、このカウンターアプリの increment() メソッドに対する単体テストを実装し、その動作を検証していきます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 2: 単体テストの目的" duration="0">
        <p>ソフトウェア開発において、単体テストの第一の目的はコード設計を改善することではなく、プロジェクトを<strong>持続可能</strong>なものにすることです。この「持続可能性」が重要な理由は、ソフトウェアは新しい機能や変更が加わるごとに自然と複雑さが増していき、保守性が低下しやすくなるためです。この複雑化（エントロピー）の進行を防ぐために、単体テストはコードの変更が意図しない影響を与えていないかを確認する「セーフティネット」としての役割を果たします。</p>
<h2 is-upgraded>ソフトウェアエントロピーと単体テストの役割</h2>
<p><strong>ソフトウェアエントロピー</strong>は、機能追加や改良を行うたびにコードが複雑化し、保守が難しくなる現象を指します。単体テストはこのエントロピーを防ぎ、コードが安定した状態を保つことに貢献します。単体テストの準備には初期の労力が必要ですが、その労力は後々のデバッグや修正の回数を減らすことで、開発効率と保守性を向上させます。</p>
<p class="image-container"><img alt="entropy" src="img/3453ffce6e4c2a31.jpg"></p>
<aside class="special"><p> 例え話 </p>
<p>単体テストは、部屋の大掃除に似ています。最初に時間をかけて徹底的に整理整頓するのは大変ですが、きちんと片付けをしておけば、後々は少しの手間で綺麗な状態を維持できるようになります。同様に、プロジェクトに最初から十分な単体テストを導入することで、最初は時間と労力が必要でも、長期的にはコードの保守が格段に楽になります。例えば、プロダクションコードのリファクタリング時にテストコードも見直し、テストが失敗した際はその原因をすぐに修正するなどの作業を通じて、テストの価値が維持され、コード全体の品質も安定します。しかし、適切なテスト設計やメンテナンスを怠ると、まるで片付けが進まない部屋のように、コードも複雑さとエラーが蓄積し、最終的にはプロジェクト全体が重荷になってしまうのです。</p>
</aside>
<h2 is-upgraded>単体テストの価値と保守コストのバランス</h2>
<p>単体テストは、コードの品質を保ちながら開発を進める上で重要ですが、テストの価値を発揮するためには単体テストの価値と保守コストの両方を考慮しなければなりません。 そしてこのコストは下記に挙げるさまざまな作業で費やされる時間が積み重なることで増加していきます。</p>
<ul>
<li>プロダクションコードのリファクタリングに伴ってテスト・コードをリファクタリングすること</li>
<li>プロダクションコードを変更するたびにテストを実施すること</li>
<li>テストが間違って失敗した際にその対処をすること</li>
<li>プロダクションコードがどのように振る舞うのかを理解するためにテストコードを読むこと</li>
</ul>
<p>これらの要点を押さえて、テストスイートを設計することで、持続可能でプロジェクト全体に貢献する価値あるテストを設計することができます。 作成した単体テストへの保守コストがあまりにもかかりすぎると、その単体テストの価値がなくなってしまう、もしくはマイナスになってしまうことがあります。</p>
<h2 is-upgraded>コードカバレッジとテストの質</h2>
<p>コードカバレッジ（テスト実行中に実行されるコード行の割合）は、テストスイートの品質を測る指標として使用されることが多いですが、<strong>カバレッジだけではテストの質は保証できません</strong>。カバレッジに過度にこだわると、カバレッジを上げるためだけに表面的なテストや冗長なテストを書く傾向が生まれることがあります。良質なテストは、カバレッジに頼るのではなく、ビジネスロジックのように失敗の影響が大きい部分に焦点を当てるべきです。</p>
<h2 is-upgraded>優れたテストスイートの特徴</h2>
<p>優れたテストスイートには以下の特徴があります：</p>
<ul>
<li><strong>開発サイクルに統合されている</strong>：テストは開発プロセスに組み込まれ、後付けではありません。</li>
<li><strong>コードベースの特に重要な部分のみがテスト対象となっている</strong>：特にビジネスロジックなどを含む部分（ドメイン・モデル）に重点を置いたテストが行われる。 <ul>
<li>インフラに関するコード</li>
<li>外部サービスや依存関係にあるもの（例：データベースやサード・パーティのシステム）</li>
</ul>
</li>
<li><strong>最小限の保守コストで最大限の価値を発揮する</strong>：テストがプロジェクト全体に持続可能な成長をもたらすよう工夫されている。</li>
</ul>
<p>このように設計された単体テストによって、コードベースの複雑化を抑えながら、プロジェクト全体が安心して成長できる基盤を築くことができます。</p>
<h2 is-upgraded>次のステップ</h2>
<p>次のステップでは、単体テストの書き方や考え方の違いを深掘りし、古典学派とロンドン学派という2つの主要なアプローチについて学びます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 3: 単体テストの学派（古典 vs ロンドン）" duration="0">
        <p>単体テストには、<strong>古典学派</strong>と<strong>ロンドン学派</strong>という2つの主要な考え方があります。この違いは、特に「テストをどこまで隔離するか」という点に基づいており、それぞれが異なるアプローチでテストの信頼性や独立性を確保しています。</p>
<h2 is-upgraded>単体テストの定義</h2>
<p>一般に単体テストは以下のように定義されます：</p>
<ul>
<li>少量のコードで検証ができる</li>
<li>実行時間が短い</li>
<li>他のコンポーネントから隔離されている</li>
</ul>
<p>この「隔離」に対する考え方の違いが、古典学派とロンドン学派の違いを生んでいます。以下で、それぞれのアプローチを見ていきましょう。</p>
<h2 is-upgraded>古典学派</h2>
<p>古典学派では、実際のインスタンスをテストケース内で生成し、プロダクションコードの実際の挙動をテストします。依存関係も基本的に実際のものを使用するため、コードそのものの動作を確認しやすいという特徴があります。以下に古典学派の例を示します：</p>
<pre><code language="language-kotlin" class="language-kotlin">@Test
fun `test person instance creation`() {
    // インスタンスを作成
    val person = Person(&#34;Taro&#34;, 25)
    
    // プロパティの値をテスト
    assertEquals(&#34;Taro&#34;, person.name, &#34;名前が正しくありません&#34;)
    assertEquals(25, person.age, &#34;年齢が正しくありません&#34;)
}
</code></pre>
<p>この方法では、依存関係が増えるとテストが複雑になることもありますが、コードの設計に依存が少なくなるような工夫を促す効果もあります。</p>
<h2 is-upgraded>ロンドン学派</h2>
<p>ロンドン学派は、テスト対象の依存関係をモック化して独立したテストを実行する「モック主義者」とも呼ばれるアプローチです。テスト内でモックを生成し、必要な動作のみを模倣させることで、テストケースごとにデータや状態が完全に独立したものになります。以下にロンドン学派の例を示します：</p>
<pre><code language="language-kotlin" class="language-kotlin">@Test
fun `test person instance creation`() {
    // モックを作成
    val person = mock&lt;Person&gt;()
    whenever(person.name).thenReturn(&#34;Taro&#34;)
    whenever(person.age).thenReturn(25)
    
    // プロパティの値をテスト
    assertEquals(&#34;Taro&#34;, person.name, &#34;名前が正しくありません&#34;)
    assertEquals(25, person.age, &#34;年齢が正しくありません&#34;)
}
</code></pre>
<p>ロンドン学派は、テスト対象のクラス（「1つのクラス」）を単体と見なし、他の依存を全てモック化することによって独立性を保ちます。このため、依存が多いコードに適していますが、モック化の量が増えるとテストのメンテナンスが複雑になる可能性があります。</p>
<h2 is-upgraded>学派の特徴と選択のポイント</h2>
<ul>
<li>古典学派：実際のプロダクションコードを使い、テストケースをコード全体の挙動と合わせて設計します。設計の見直しを促し、シンプルなテストが可能です。</li>
<li>ロンドン学派：モックを多用し、テストをクラス単位で隔離して実施します。依存を多く持つ複雑なコードには適していますが、モックが多くなるとテストが煩雑になることがあります。</li>
</ul>
<h2 is-upgraded>ロンドン学派は課題もいくつか抱えている。</h2>
<p>ロンドン学派の長所は魅力的なように思えるが、単体テストにおいて、テスト対象の焦点をクラスに当てることは間違いです。 焦点を当てるべきは１単位のコードではなく、１単位の振る舞いです。</p>
<table>
<tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><p>隔離対象</p>
</td><td colspan="1" rowspan="1"><p>単体の意味</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>ロンドン学派</p>
</td><td colspan="1" rowspan="1"><p>単体</p>
</td><td colspan="1" rowspan="1"><p>1つのクラス</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>古典学派</p>
</td><td colspan="1" rowspan="1"><p>テスト・ケース</p>
</td><td colspan="1" rowspan="1"><p>１つのクラス、もしくは、同じ目的を達成するためのクラスの１グループ</p>
</td></tr>
</table>
<p>この場合、ロンドン学派では、検証内容が詳細になりすぎてしまうことがあります。単体テストが内部構造と深く結びついてしまうことで、保守性の低いテストコードになってしまうからです。（詳細についてはstep5で説明します。）</p>
<h2 is-upgraded>次のステップ</h2>
<p>次のステップでは、単体テストの基本的な構造と、広く使用される<strong>AAAパターン</strong>（Arrange-Act-Assert）について学びます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 4: 単体テストの構造とAAAパターン" duration="0">
        <p>内容: Arrange-Act-Assert（AAA）パターンでのテスト構造を示し、コードを一貫性のある構造にします。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 5: 良いテストの4本の柱" duration="0">
        <p>内容: CounterScreenのUIテストで状態が正しく表示されているか確認し、リファクタリング耐性と保守性について学びます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 6: テストダブルの活用" duration="0">
        <p>内容: モックとスタブの違いを理解し、ログを持つViewModelのテストでモック化を体験します。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 7: 単体テストの3つの手法" duration="0">
        <p>内容: 出力値ベース、状態ベース、コミュニケーションベースの3つのテスト手法を示します。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 8: 複雑なコードのリファクタリング" duration="0">
        <p>内容: ViewModelに履歴機能を持たせ、ビジネスロジックとUIの分離を学びます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step 9: 完成形とまとめ" duration="0">
        <p>完成形コード: 最終的なCounterアプリとテストコードを確認します。 まとめ: テストの基本原則とJetpack Compose特有のUIテストの利点を確認し、リファクタリング耐性と保守性について学びます。</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
